# Features

- Declarative typed configuration with schema validation
- Open schema model using YAML + CUE + JSON Schema
- Configuration composition via includes, imports, and overlays
- Role/profile/environment inheritance model
- Node classification rules based on facts, labels, and policy
- Variable precedence model with explicit conflict resolution
- `explain` command to show final merged variable values
- Built-in templating engine with safe function library
- Template rendering strict mode with undefined-variable failure controls
- Conditionals, loops, and matrix expansion in configuration
- Handler/notification model for event-triggered resource actions
- Explicit `require`/`before`/`notify`/`subscribe` style resource relationships
- Resource refresh-on-change semantics with `only_if`/`unless` guards
- Task and plan framework with module-packaged actions and reusable orchestration primitives
- Typed task metadata with strict input validation and schema-enforced parameter contracts
- Sensitive task/plan parameter masking in logs and API responses
- Resource graph compiler with explicit dependencies, cycle detection, and diagnostics
- Resource graph query API for impact and dependency analysis
- Hierarchical data lookup engine (Hiera/Data Bag style)
- External data source plugins for variables and policy inputs
- Versioned policy bundles with lockfiles (Policyfile-style)
- Deterministic `plan` output for identical inputs
- Plan reproducibility checks across different runners
- Mandatory `plan` before every `apply`
- Read-only `check/noop` mode with exit codes for CI gating
- Change freeze enforcement and emergency override workflow
- Idempotent resource provider contract
- Provider side-effect declaration and purity metadata
- Change diff previews for every resource action
- Blast-radius estimation before apply
- Partial and targeted applies by host, group, tag, and resource
- Scoped rollback by host, resource, and execution stage
- Parallel execution with configurable concurrency limits
- Distributed execution locks to avoid conflicting runs
- Concurrency guards by environment and service criticality
- Transaction checkpoints and resumable execution
- Automatic retry policies with jitter and backoff controls
- Rollback support for reversible resources
- Execution graph visualization in CLI and UI
- Long-running run leases with heartbeat and stale-lease recovery
- Per-step execution snapshots for mid-run forensic analysis
- Asynchronous command ingestion API with checksum verification and dead-letter handling
- Run strategy modes (`linear`, `free`, `serial`)
- Failure thresholds (`max_fail_percentage`, `any_errors_fatal`-style controls)
- `block`/`rescue`/`always` execution semantics for robust error handling
- Async task execution with poll and timeout controls
- Delegated execution (`delegate_to`/local execution equivalents)
- Privilege escalation policies (`sudo`/`run-as`) with audit trails
- Static inventory management
- Dynamic inventory providers
- Cloud inventory sync for AWS, Azure, GCP, and vSphere
- Service-discovery-backed inventory sources (Consul, Kubernetes, cloud tags)
- Inventory drift detection and reconciliation
- Labels, tags, roles, and topology-based host grouping
- Runtime host discovery and auto-enrollment
- Lifecycle workflows for node bootstrap, quarantine, and decommission
- Fact collection engine (system, custom, and external facts)
- Fact caching with TTL and invalidation controls
- Agentless execution over SSH
- Agentless execution over WinRM
- Local execution mode (`connection=local` equivalent) for image builds and CI runners
- Connection plugin architecture for custom transports
- Bastion/jump-host and proxy-aware connection routing
- Session recording for privileged remote executions
- Network device transport support (NETCONF, RESTCONF, API-driven)
- Agent-based periodic converge loop
- Proxy-minion mode for devices that cannot run full agents
- Catalog compile-and-distribute flow for agent runs
- Compiled catalog caching and signed catalog replay on disconnected nodes
- Agent check-in jitter/splay controls to prevent thundering herd
- Message-bus option for scalable agent dispatch
- Agent certificate issuance, rotation, and revocation workflows
- Policy-based certificate autosigning with CSR attribute validation and manual-approval fallback
- Hybrid push + pull mode per environment
- Secure bootstrap flow from agentless to agent mode
- Policy pull from control plane or signed Git sources
- Multi-master control mode with centralized job/event cache
- Separation of control and execution planes for independent scaling
- Overlay execution mesh with peer routing and hop nodes
- Egress-only execution-node connectivity via hosted hop/ingress relays
- Cross-platform support for Linux, macOS, and Windows nodes
- Windows-specific resources for DSC, PowerShell, services, and registry
- Package manager abstraction for apt, yum/dnf, zypper, brew, winget, and chocolatey
- Core resources for file, directory, template, package, service, user, group, command, cron, and sysctl
- Advanced resources for firewall, kernel module, mount, certificate, registry, and scheduled tasks
- SELinux/AppArmor policy and context management resources
- Systemd unit management and drop-in override resources
- Artifact deployment resources with checksum pinning and staged rollout
- Reboot orchestration resource with safe dependency handling
- Patch management resource for scheduled OS updates
- Package version pinning, hold/unhold, and drift enforcement
- File integrity enforcement using checksum and signed content metadata
- Container and Kubernetes resource providers
- Cloud service resource providers for common infrastructure operations
- Image baking and golden-image pipeline hooks
- Dependency-aware orchestration and ordered phases
- Rolling updates with health checks
- Blue/green and canary rollout strategies
- Serial, batch, and percentage rollout controls
- Failure domain aware orchestration by rack, zone, and region
- Maintenance windows and disruption budgets
- Pre-flight checks before execution
- Runtime assertions and post-change verification gates
- Health probe integrations to gate promotion and rollback
- Pre-run policy simulation with host-level explain output
- Post-run invariant checks with configurable failure severity
- Per-policy enforcement modes: audit, apply-and-monitor, and apply-and-autocorrect
- Desired-state snapshot storage
- Observed-state collection and normalization
- Continuous drift detection
- Drift suppression windows and approved-difference allowlists
- Drift alerting with severity levels
- Policy-driven auto-remediation of approved drift
- Safe mode to block high-risk automatic changes
- Drift root-cause hints and remediation recommendations
- Desired-vs-observed diff history with trend analytics
- Run history with full audit trail
- Immutable event logs for every action
- Real-time run streaming and event subscriptions
- Structured logs, metrics, traces, and run replay
- OpenTelemetry-native export for logs, metrics, and traces
- Unified CLI with `init`, `validate`, `plan`, `apply`, `observe`, `drift`, `policy`, and `doctor`
- Interactive approval prompts and non-interactive CI-safe modes
- Rich diff output formats (human, JSON, machine-readable patch)
- Deterministic machine-readable run report output for pipeline consumption
- Ad hoc command mode with guardrails and audit logging
- CLI TUI mode for interactive run inspection
- Web UI for plans, runs, drift, compliance, and approvals
- Activity stream API and UI timeline for identity/resource change auditing
- Fleet health dashboards with SLO and error-budget views
- Self-service catalog for approved runbooks
- REST API and gRPC API for automation integration
- Event bus integrations (Kafka, NATS, webhooks)
- Rulebook/event source engine with source-rule-condition-action pipelines
- Event stream ingress endpoints for external SaaS and webhook producers
- GitOps workflow support with signed plan artifacts
- Pull-request plan comments and approval gates
- Multi-environment promotions with policy checks
- Drift-aware GitOps reconciliation loop
- Branch-based ephemeral environment previews for infrastructure changes
- Promotion pipelines with immutable artifact pinning
- Branch-per-environment control-repo workflow with automatic environment materialization
- Webhook, API, and CLI triggers for environment code deployments
- Staging-to-live file-sync pipeline for distributed compiler/worker nodes
- Secrets manager integrations
- Built-in encrypted secrets store with envelope encryption
- Secret rotation workflows and expiry enforcement
- Secret usage tracing and redaction-by-default logs
- Encrypted variable files with key rotation (Vault-style)
- Runtime secret materialization in memory only with zeroization after use
- Short-lived execution credentials
- mTLS between all components
- OIDC workload identity support
- Signed module and provider packages
- Provenance metadata for modules and providers
- Sigstore/Cosign signature verification support
- Signed collection/image policy enforcement with client-side verification keyrings
- Policy engine for pre-apply and runtime guardrails
- Policy simulation mode before enforcement
- Policy bundles with staged rollout and canary enforcement
- Command/resource allowlists and deny policies
- ABAC and context-aware policy conditions
- RBAC with scoped permissions
- SSO and enterprise identity integration
- SCIM provisioning for teams and roles
- Break-glass workflow with audited approvals
- Multi-stage approvals with quorum rules
- Just-in-time access grants for sensitive operations
- Time-bound delegation tokens for automated run pipelines
- Compliance profile engine (CIS, STIG, custom)
- Continuous compliance scans
- Compliance evidence exports (JSON, SARIF, CSV)
- Compliance exceptions with expiration and approvals
- Compliance scorecards by team, environment, and service
- Provider SDK with conformance testing
- Provider test fixtures and contract test harness
- Versioned provider protocol with backward compatibility guarantees
- Provider capability negotiation and feature-flag compatibility mapping
- Sandboxed third-party providers with least privilege isolation
- WASI runtime support for untrusted provider plugins
- Module registry with versioning and signatures
- Private and public registry support
- Curated content channels (certified, validated, community) with controlled sync lists
- Per-organization sync remotes secured by API tokens
- Module dependency resolution and lockfiles
- Module scaffolding generator and best-practice templates
- Module quality scoring and trust badges
- Module provenance attestation and dependency vulnerability reports
- Event hooks and webhooks
- Notification integrations for ChatOps and incident systems
- Ticketing system integrations for change records and approvals
- Report processor plugins for custom post-run processing
- Remote execution API for one-off fleet commands
- Ephemeral execution workers for burst orchestration
- Control plane scheduler and distributed worker queues
- Multi-queue priority classes and fair scheduling
- Workflow engine for multi-step orchestration pipelines
- HA control plane reference architecture
- Multi-region control plane federation
- Regional failover and active-active operation mode
- Edge relay mode for intermittently connected sites
- PostgreSQL-backed state and event storage
- Pluggable queue backends for scale and resiliency
- Pluggable object storage for artifacts and logs
- Backup and disaster recovery workflows
- Point-in-time restore for state and audit data
- Control plane schema migrations with forward/backward compatibility checks
- Disaster recovery drills with automated restore verification
- Scheduled association-style policy assignments with revision history and replay controls
- Association execution output export to object storage for long-term evidence retention
- Scale profile for fleets from 10 to 10,000+ nodes
- Fleet sharding and tenancy-aware scheduler partitioning
- Performance profiling and bottleneck diagnostics
- Cost-aware scheduling and throttling controls
- Bandwidth-aware artifact distribution and caching
- Workspace and multi-tenant isolation
- Hard tenant boundaries with per-tenant crypto keys
- Delegated administration per tenant and environment
- Per-tenant rate limits and noisy-neighbor protections
- Policy and config linting
- Built-in test harness for modules and policies
- End-to-end scenario test runner for fleet simulations
- Ephemeral test environment runner for integration checks
- Golden-run baselines and regression detection
- Continuous conformance suite for built-in providers
- Deterministic snapshot tests for plan output stability
- Fault-injection and chaos testing for orchestrator resilience
- Migration tooling from Chef cookbooks
- Migration tooling from Ansible playbooks
- Migration tooling from Puppet manifests
- Compatibility shims for common legacy patterns
- Migration assessment report with parity and risk scoring
- Import/export tooling for existing inventories and variables
- Bulk import from CMDB and asset inventory systems
- Import assistants for existing secrets, facts, and role/group hierarchies
- Offline and air-gapped operation mode
- Signed offline bundle creation and verification
- Offline registry mirroring and synchronization tooling
- FIPS-compatible cryptography mode for regulated environments
- Contributor-friendly local development environment
- Local single-binary dev mode for control plane + worker + registry
- Public plugin and module certification pipeline
- Security and quality gates for publication to public registry
- Documentation generator for modules, providers, and policy APIs
- Deprecation warnings and automated upgrade assistant for breaking changes
- Stability channels for control plane and agents (`stable`, `candidate`, `edge`)
- Zero-downtime upgrade orchestration for agents and controllers
- N-1 protocol compatibility policy
- Forward-compatible API versioning and deprecation lifecycle guarantees
- Long-term support (LTS) release channel and support matrix
- Release artifact signing and SBOM generation
- Vulnerability scanning and CVE policy enforcement on releases
