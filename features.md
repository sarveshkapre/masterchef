# Features

- Declarative typed configuration with schema validation
- Open schema model using YAML + CUE + JSON Schema
- Configuration composition via includes, imports, and overlays
- Role/profile/environment inheritance model
- Chef-style role and environment objects with file-backed and API-backed workflows
- Per-environment run-list and policy overrides with deterministic precedence
- Node classification rules based on facts, labels, and policy
- External node classifier (ENC) interface for third-party classification engines
- Variable precedence model with explicit conflict resolution
- `explain` command to show final merged variable values
- Variable source graph and precedence conflict detector with hard-fail policy option
- Ambiguous variable override warnings with actionable remediation hints
- Built-in templating engine with safe function library
- Template rendering strict mode with undefined-variable failure controls
- Conditionals, loops, and matrix expansion in configuration
- Handler/notification model for event-triggered resource actions
- Explicit `require`/`before`/`notify`/`subscribe` style resource relationships
- Resource refresh-on-change semantics with `only_if`/`unless` guards
- Task and plan framework with module-packaged actions and reusable orchestration primitives
- Typed task metadata with strict input validation and schema-enforced parameter contracts
- Sensitive task/plan parameter masking in logs and API responses
- Resource graph compiler with explicit dependencies, cycle detection, and diagnostics
- Resource graph query API for impact and dependency analysis
- Hierarchical data lookup engine (Hiera/Data Bag style)
- External data source plugins for variables and policy inputs
- Data bag/global object store with encrypted item support and structured search
- Pillar-style hierarchical data with explicit merge strategies (`merge-first`, `merge-last`, `overwrite`, `remove`)
- Versioned policy bundles with lockfiles (Policyfile-style)
- Named run-lists and policy-group targeting for staged rollout promotion
- Deterministic `plan` output for identical inputs
- Plan reproducibility checks across different runners
- Mandatory `plan` before every `apply`
- Read-only `check/noop` mode with exit codes for CI gating
- Full-fidelity simulation contract for built-in providers (no silent skip behavior)
- Plan confidence scoring that flags non-simulatable actions before execution
- Policy gate to block applies below minimum simulation confidence
- Simulation coverage report per provider/module with explicit unsupported-action inventory
- Change freeze enforcement and emergency override workflow
- Idempotent resource provider contract
- Provider side-effect declaration and purity metadata
- Change diff previews for every resource action
- Blast-radius estimation before apply
- Partial and targeted applies by host, group, tag, and resource
- Scoped rollback by host, resource, and execution stage
- Parallel execution with configurable concurrency limits
- Distributed execution locks to avoid conflicting runs
- Concurrency guards by environment and service criticality
- Adaptive concurrency controller that auto-tunes parallelism by host health and failure rate
- Transaction checkpoints and resumable execution
- Automatic retry policies with jitter and backoff controls
- Rollback support for reversible resources
- Execution graph visualization in CLI and UI
- Long-running run leases with heartbeat and stale-lease recovery
- Per-step execution snapshots for mid-run forensic analysis
- Asynchronous command ingestion API with checksum verification and dead-letter handling
- Run strategy modes (`linear`, `free`, `serial`)
- Failure thresholds (`max_fail_percentage`, `any_errors_fatal`-style controls)
- `block`/`rescue`/`always` execution semantics for robust error handling
- Async task execution with poll and timeout controls
- Delegated execution (`delegate_to`/local execution equivalents)
- Privilege escalation policies (`sudo`/`run-as`) with audit trails
- Task tags with include/exclude run filters for selective execution
- Step-level retries and `until`-style retry conditions for transient failures
- Static inventory management
- Dynamic inventory providers
- Cloud inventory sync for AWS, Azure, GCP, and vSphere
- Service-discovery-backed inventory sources (Consul, Kubernetes, cloud tags)
- Inventory drift detection and reconciliation
- Labels, tags, roles, and topology-based host grouping
- Runtime host discovery and auto-enrollment
- Lifecycle workflows for node bootstrap, quarantine, and decommission
- Fact collection engine (system, custom, and external facts)
- Fact caching with TTL and invalidation controls
- Salt-style grains compatibility layer over fact data for migration ease
- Cross-node shared fact cache (Salt Mine style) for service-discovery and orchestration use cases
- Agentless execution over SSH
- Agentless execution over WinRM
- Local execution mode (`connection=local` equivalent) for image builds and CI runners
- Pythonless managed-node execution path using portable remote runners where feasible
- Capability discovery per node to select best execution backend automatically
- Connection plugin architecture for custom transports
- Bastion/jump-host and proxy-aware connection routing
- Session recording for privileged remote executions
- Network device transport support (NETCONF, RESTCONF, API-driven)
- Agent-based periodic converge loop
- Event-triggered converge runs in addition to interval-based scheduling
- Real-time converge trigger API for policy, package, and security events
- Native scheduler first approach (systemd timers, cron, Windows scheduled tasks) for recurring runs
- Short-lived stateless worker execution model to avoid long-running process state drift
- Proxy-minion mode for devices that cannot run full agents
- Catalog compile-and-distribute flow for agent runs
- Compiled catalog caching and signed catalog replay on disconnected nodes
- Agent check-in jitter/splay controls to prevent thundering herd
- Message-bus option for scalable agent dispatch
- Agent certificate issuance, rotation, and revocation workflows
- Policy-based certificate autosigning with CSR attribute validation and manual-approval fallback
- Zero-touch certificate lifecycle with automatic renewal and expiry SLO alerts
- Identity bootstrap with hardware/cloud attestation before certificate issuance
- Hybrid push + pull mode per environment
- Secure bootstrap flow from agentless to agent mode
- Policy pull from control plane or signed Git sources
- Multi-master control mode with centralized job/event cache
- Separation of control and execution planes for independent scaling
- Overlay execution mesh with peer routing and hop nodes
- Egress-only execution-node connectivity via hosted hop/ingress relays
- Minimal-footprint deployment profile (single binary, embedded defaults, no external queue)
- Progressive deployment profiles from single-node to HA without architecture rewrites
- Guided topology advisor for scaling from small teams to large fleets without replatforming
- Cross-platform support for Linux, macOS, and Windows nodes
- Windows-specific resources for DSC, PowerShell, services, and registry
- Package manager abstraction for apt, yum/dnf, zypper, brew, winget, and chocolatey
- Core resources for file, directory, template, package, service, user, group, command, cron, and sysctl
- Advanced resources for firewall, kernel module, mount, certificate, registry, and scheduled tasks
- Virtual and exported resource model with collector syntax for cross-node service discovery patterns
- Filebucket-style content backup and checksum-addressable file history for managed files
- SELinux/AppArmor policy and context management resources
- Systemd unit management and drop-in override resources
- Artifact deployment resources with checksum pinning and staged rollout
- Reboot orchestration resource with safe dependency handling
- Patch management resource for scheduled OS updates
- Package version pinning, hold/unhold, and drift enforcement
- File integrity enforcement using checksum and signed content metadata
- Container and Kubernetes resource providers
- Cloud service resource providers for common infrastructure operations
- Image baking and golden-image pipeline hooks
- Dependency-aware orchestration and ordered phases
- Rolling updates with health checks
- Blue/green and canary rollout strategies
- Serial, batch, and percentage rollout controls
- Failure domain aware orchestration by rack, zone, and region
- Maintenance windows and disruption budgets
- Pre-flight checks before execution
- Runtime assertions and post-change verification gates
- Health probe integrations to gate promotion and rollback
- Pre-run policy simulation with host-level explain output
- Post-run invariant checks with configurable failure severity
- Per-policy enforcement modes: audit, apply-and-monitor, and apply-and-autocorrect
- Desired-state snapshot storage
- Observed-state collection and normalization
- Continuous drift detection
- Drift suppression windows and approved-difference allowlists
- Drift alerting with severity levels
- Policy-driven auto-remediation of approved drift
- Safe mode to block high-risk automatic changes
- Drift SLO tracking with breach alerts and automated incident creation hooks
- Drift root-cause hints and remediation recommendations
- Desired-vs-observed diff history with trend analytics
- Stateful desired/observed store available for both agentless and agent modes
- Run history with full audit trail
- Immutable event logs for every action
- Real-time run streaming and event subscriptions
- Exception and report handler pipeline with pluggable sinks and ordered execution
- Structured logs, metrics, traces, and run replay
- OpenTelemetry-native export for logs, metrics, and traces
- Correlation IDs linking each run step to external observability systems
- Run failure triage bundle export (logs, facts, diffs, provider output, host metadata)
- Cross-run diff analysis to compare failed and successful executions
- Unified CLI with `init`, `validate`, `plan`, `apply`, `observe`, `drift`, `policy`, and `doctor`
- Interactive approval prompts and non-interactive CI-safe modes
- Rich diff output formats (human, JSON, machine-readable patch)
- Deterministic machine-readable run report output for pipeline consumption
- Ad hoc command mode with guardrails and audit logging
- CLI TUI mode for interactive run inspection
- Web UI for plans, runs, drift, compliance, and approvals
- Persona-based home views for SRE, platform, release, and service-owner workflows
- Command palette with universal search across hosts, services, runs, policies, and modules
- Keyboard-first navigation for all core workflows with no-mouse execution paths
- Progressive disclosure UI that starts simple and reveals advanced controls on demand
- Guided workflow wizards for bootstrap, rollout, rollback, and incident remediation
- Topology-aware blast-radius map showing impacted services, dependencies, and owners
- Explainability panel for every plan step: why this change exists, what triggered it, and expected outcome
- Human-readable risk summaries with actionable mitigation suggestions before apply
- One-click safe rollback and one-click retry from failure context
- Bulk operations UX with preview, conflict detection, and staged confirmation
- Saved views, shareable filters, and pin-to-dashboard widgets for team workflows
- Workload-centric views that group by service/application instead of only host inventory
- Time-travel run timeline to replay environment state before, during, and after a change
- Cross-signal incident view combining run events, drift, health checks, and observability links
- On-call handoff package generator with current risks, active rollouts, and blocked actions
- Noise-reduction alert inbox with deduplication, suppression windows, and priority routing
- Operator checklist mode for high-risk changes with explicit pre/post verification prompts
- What-changed digest for each deployment window with success/failure and latent-risk scoring
- Fleet-scale UI performance mode for 100k+ nodes with virtualized tables and incremental loading
- Low-bandwidth UI mode optimized for remote operations and degraded network conditions
- Built-in docs and inline examples at point of action, not separate documentation hunting
- Workspace templates for common big-tech patterns (stateless services, stateful clusters, edge fleets)
- Opinionated solution packs for stateless microservices on VMs and Kubernetes
- Opinionated solution packs for stateful databases (PostgreSQL, MySQL, MongoDB) with maintenance-safe orchestration
- Opinionated solution packs for caching tiers (Redis, Memcached) with shard-aware rollouts
- Opinionated solution packs for messaging/streaming platforms (Kafka, RabbitMQ, NATS)
- Opinionated solution packs for search and analytics clusters (OpenSearch, Elasticsearch, ClickHouse)
- Opinionated solution packs for observability stacks (Prometheus, OpenTelemetry collectors, log pipelines)
- Opinionated solution packs for CI/CD worker fleets and ephemeral build runners
- Opinionated solution packs for GPU/accelerator fleet provisioning and runtime tuning
- Opinionated solution packs for ML training clusters and model-serving fleets
- Opinionated solution packs for batch processing and data pipeline worker pools
- Opinionated solution packs for edge/retail/branch deployments with intermittent connectivity
- Opinionated solution packs for network and security appliance configuration at scale
- Opinionated solution packs for hybrid datacenter + cloud migration waves
- Opinionated solution packs for SaaS multi-tenant platform operations
- Use-case templates for blue/green, canary, and rolling application releases with traffic gates
- Use-case templates for zero-downtime OS patching and coordinated reboot campaigns
- Use-case templates for large-scale certificate rotation and trust store updates
- Use-case templates for database schema-change orchestration with preflight and rollback hooks
- Use-case templates for disaster recovery cutover, failback, and post-recovery reconciliation
- Use-case templates for fleet-wide emergency remediation of critical vulnerabilities
- Use-case templates for seasonal scale-up and scale-down operations with guardrails
- Use-case templates for brownfield onboarding and legacy-to-modern migration programs
- Use-case templates for service ownership transfer and platform tenancy carve-outs
- Consistent object model and naming across CLI, UI, and API to reduce context switching
- Accessibility-first UX (screen-reader support, full keyboard controls, high-contrast themes)
- Activity stream API and UI timeline for identity/resource change auditing
- Fleet health dashboards with SLO and error-budget views
- Self-service catalog for approved runbooks
- REST API and gRPC API for automation integration
- Event bus integrations (Kafka, NATS, webhooks)
- Rulebook/event source engine with source-rule-condition-action pipelines
- Event stream ingress endpoints for external SaaS and webhook producers
- Salt-style beacon/reactor compatibility patterns for event-driven remediation
- GitOps workflow support with signed plan artifacts
- Pull-request plan comments and approval gates
- Multi-environment promotions with policy checks
- Drift-aware GitOps reconciliation loop
- Branch-based ephemeral environment previews for infrastructure changes
- Promotion pipelines with immutable artifact pinning
- Branch-per-environment control-repo workflow with automatic environment materialization
- Webhook, API, and CLI triggers for environment code deployments
- Staging-to-live file-sync pipeline for distributed compiler/worker nodes
- Secrets manager integrations
- Built-in encrypted secrets store with envelope encryption
- Secret rotation workflows and expiry enforcement
- Secret usage tracing and redaction-by-default logs
- Encrypted variable files with key rotation (Vault-style)
- Runtime secret materialization in memory only with zeroization after use
- Hermetic execution environments with pinned dependency sets for reproducible runs
- Signed execution environment images with policy enforcement at run admission
- Short-lived execution credentials
- mTLS between all components
- OIDC workload identity support
- Signed module and provider packages
- Provenance metadata for modules and providers
- Sigstore/Cosign signature verification support
- Signed collection/image policy enforcement with client-side verification keyrings
- Policy engine for pre-apply and runtime guardrails
- Policy simulation mode before enforcement
- Policy bundles with staged rollout and canary enforcement
- Command/resource allowlists and deny policies
- ABAC and context-aware policy conditions
- RBAC with scoped permissions
- SSO and enterprise identity integration
- SCIM provisioning for teams and roles
- Break-glass workflow with audited approvals
- Multi-stage approvals with quorum rules
- Just-in-time access grants for sensitive operations
- Time-bound delegation tokens for automated run pipelines
- Compliance profile engine (CIS, STIG, custom)
- Continuous compliance scans
- Compliance evidence exports (JSON, SARIF, CSV)
- Compliance exceptions with expiration and approvals
- Compliance scorecards by team, environment, and service
- Provider SDK with conformance testing
- Provider test fixtures and contract test harness
- Versioned provider protocol with backward compatibility guarantees
- Provider capability negotiation and feature-flag compatibility mapping
- Ansible-compatible plugin extension points (callback, lookup, filter, vars, strategy)
- Sandboxed third-party providers with least privilege isolation
- WASI runtime support for untrusted provider plugins
- Module registry with versioning and signatures
- Private and public registry support
- Curated content channels (certified, validated, community) with controlled sync lists
- Per-organization sync remotes secured by API tokens
- Module dependency resolution and lockfiles
- Module scaffolding generator and best-practice templates
- Module quality scoring and trust badges
- Module provenance attestation and dependency vulnerability reports
- Event hooks and webhooks
- Notification integrations for ChatOps and incident systems
- Ticketing system integrations for change records and approvals
- Report processor plugins for custom post-run processing
- Remote execution API for one-off fleet commands
- Ephemeral execution workers for burst orchestration
- Global emergency stop to halt new applies across selected environments
- In-flight run pause, resume, cancel, and safe-drain controls
- Idempotent run request keys with duplicate suppression
- Stuck-run detector with automatic lease recovery and operator handoff
- Control plane scheduler and distributed worker queues
- Multi-queue priority classes and fair scheduling
- Scheduler-aware maintenance mode for hosts, clusters, and environments
- Capacity-aware scheduling using host health, backlog pressure, and execution cost
- Queue backlog SLO tracking with predictive saturation alerts
- Workflow engine for multi-step orchestration pipelines
- Job templates, workflow templates, schedules, and prompted launch parameters
- Survey/form-driven run launches with schema-validated inputs
- HA control plane reference architecture
- Production deployment blueprints for Kubernetes, VMs, and bare metal
- Preflight deployment validator for network, DNS, storage, database, and queue dependencies
- One-command bootstrap for single-region HA control plane
- Control plane synthetic canary jobs for continuous health verification
- Control plane canary upgrade workflow with automatic rollback on regression
- Multi-region control plane federation
- Regional failover and active-active operation mode
- Automated regional failover drills with recovery time scorecards
- Edge relay mode for intermittently connected sites
- PostgreSQL-backed state and event storage
- Pluggable queue backends for scale and resiliency
- Pluggable object storage for artifacts and logs
- Query API for facts, resources, events, reports, and catalogs with both human-friendly and AST modes
- Backup and disaster recovery workflows
- Point-in-time restore for state and audit data
- Control plane schema migrations with forward/backward compatibility checks
- Disaster recovery drills with automated restore verification
- Scheduled association-style policy assignments with revision history and replay controls
- Association execution output export to object storage for long-term evidence retention
- Scale profile for fleets from 10 to 10,000+ nodes
- Fleet sharding and tenancy-aware scheduler partitioning
- Performance profiling and bottleneck diagnostics
- Topology-aware run placement by region, zone, cluster, and failure domain
- Adaptive worker autoscaling based on queue depth and execution latency
- Cost-aware scheduling and throttling controls
- Bandwidth-aware artifact distribution and caching
- Workspace and multi-tenant isolation
- Hard tenant boundaries with per-tenant crypto keys
- Delegated administration per tenant and environment
- Per-tenant rate limits and noisy-neighbor protections
- Policy and config linting
- Built-in style and best-practice analyzers for policies, modules, and provider code
- Breaking-change detector for module and provider interface updates
- API contract testing with backward/forward compatibility reports
- Strict schema evolution rules with migration plans required for state model changes
- Deterministic formatting and canonicalization for configs and plans
- Built-in test harness for modules and policies
- Mutation testing support for critical provider logic
- Property-based testing harness for idempotency and convergence invariants
- Load and soak test suites for control plane, scheduler, and execution workers
- Performance regression gates with latency/throughput/error budget thresholds
- Memory and resource leak detection in long-running components
- Flake detection and quarantine pipeline for unstable tests
- Test impact analysis to run only relevant suites while preserving safety
- End-to-end scenario test runner for fleet simulations
- Ephemeral test environment runner for integration checks
- Golden-run baselines and regression detection
- Continuous conformance suite for built-in providers
- Deterministic snapshot tests for plan output stability
- Fault-injection and chaos testing for orchestrator resilience
- Reproducible local build and test pipeline with pinned toolchains
- Automated dependency update bot with compatibility and performance verification
- Release readiness scorecard aggregating quality, reliability, and performance signals
- Release blocker policy that enforces minimum craftsmanship thresholds
- Migration tooling from Chef cookbooks
- Migration tooling from Ansible playbooks
- Migration tooling from Puppet manifests
- Compatibility shims for common legacy patterns
- Migration assessment report with parity and risk scoring
- Semantic equivalence testing for migrated policies before production rollout
- Auto-generated migration diff reports highlighting behavior mismatches
- Deprecation-risk scanner for source platforms and modules with migration urgency scoring
- Import/export tooling for existing inventories and variables
- Bulk import from CMDB and asset inventory systems
- Import assistants for existing secrets, facts, and role/group hierarchies
- Brownfield bootstrap from existing host state into managed desired-state baselines
- Offline and air-gapped operation mode
- Signed offline bundle creation and verification
- Offline registry mirroring and synchronization tooling
- Masterless execution mode with local state/pillar rendering for disconnected operations
- Hierarchical relay/syndic topology for very large fleets and segmented networks
- FIPS-compatible cryptography mode for regulated environments
- Contributor-friendly local development environment
- Local single-binary dev mode for control plane + worker + registry
- Public plugin and module certification pipeline
- Security and quality gates for publication to public registry
- Craftsmanship badge tiers (bronze/silver/gold) based on objective quality metrics
- Maintainer health metrics for modules/providers (test pass rate, issue latency, release cadence)
- Documentation generator for modules, providers, and policy APIs
- Executable documentation examples verified in CI
- API docs with version-diff views and deprecation timelines
- Deprecation warnings and automated upgrade assistant for breaking changes
- Stability channels for control plane and agents (`stable`, `candidate`, `edge`)
- Zero-downtime upgrade orchestration for agents and controllers
- N-1 protocol compatibility policy
- Forward-compatible API versioning and deprecation lifecycle guarantees
- Long-term support (LTS) release channel and support matrix
- Release artifact signing and SBOM generation
- Vulnerability scanning and CVE policy enforcement on releases
- Release provenance attestations linked to source commit, test runs, and build environment
