# Features

- Declarative typed configuration with schema validation
- Resource graph compiler with explicit dependencies
- Deterministic `plan` output for identical inputs
- Mandatory `plan` before every `apply`
- Idempotent resource provider contract
- Change diff previews for every resource action
- Partial and targeted applies by host, group, tag, and resource
- Parallel execution with configurable concurrency limits
- Transaction checkpoints and resumable execution
- Rollback support for reversible resources
- Static inventory management
- Dynamic inventory providers
- Labels, tags, roles, and topology-based host grouping
- Runtime host discovery and auto-enrollment
- Agentless execution over SSH
- Agentless execution over WinRM
- Agent-based periodic converge loop
- Hybrid push + pull mode per environment
- Secure bootstrap flow from agentless to agent mode
- Cross-platform support for Linux, macOS, and Windows nodes
- Core resources for file, directory, template, package, service, user, group, command, cron, and sysctl
- Advanced resources for firewall, kernel module, mount, certificate, registry, and scheduled tasks
- Dependency-aware orchestration and ordered phases
- Rolling updates with health checks
- Blue/green and canary rollout strategies
- Maintenance windows and disruption budgets
- Pre-flight checks before execution
- Runtime assertions and post-change verification gates
- Desired-state snapshot storage
- Observed-state collection and normalization
- Continuous drift detection
- Drift alerting with severity levels
- Policy-driven auto-remediation of approved drift
- Safe mode to block high-risk automatic changes
- Run history with full audit trail
- Immutable event logs for every action
- Structured logs, metrics, traces, and run replay
- Unified CLI with `init`, `validate`, `plan`, `apply`, `observe`, `drift`, `policy`, and `doctor`
- Web UI for plans, runs, drift, compliance, and approvals
- REST API and gRPC API for automation integration
- GitOps workflow support with signed plan artifacts
- Pull-request plan comments and approval gates
- Multi-environment promotions with policy checks
- Secrets manager integrations
- Short-lived execution credentials
- mTLS between all components
- Signed module and provider packages
- Provenance metadata for modules and providers
- Policy engine for pre-apply and runtime guardrails
- Command/resource allowlists and deny policies
- RBAC with scoped permissions
- SSO and enterprise identity integration
- Break-glass workflow with audited approvals
- Compliance profile engine (CIS, STIG, custom)
- Continuous compliance scans
- Compliance evidence exports (JSON, SARIF, CSV)
- Compliance exceptions with expiration and approvals
- Provider SDK with conformance testing
- Versioned provider protocol with backward compatibility guarantees
- Sandboxed third-party providers with least privilege isolation
- Module registry with versioning and signatures
- Private and public registry support
- Module dependency resolution and lockfiles
- Event hooks and webhooks
- Notification integrations for ChatOps and incident systems
- Remote execution API for one-off fleet commands
- Ephemeral execution workers for burst orchestration
- Control plane scheduler and distributed worker queues
- HA control plane reference architecture
- PostgreSQL-backed state and event storage
- Pluggable object storage for artifacts and logs
- Backup and disaster recovery workflows
- Scale profile for fleets from 10 to 10,000+ nodes
- Performance profiling and bottleneck diagnostics
- Cost-aware scheduling and throttling controls
- Workspace and multi-tenant isolation
- Policy and config linting
- Built-in test harness for modules and policies
- Ephemeral test environment runner for integration checks
- Golden-run baselines and regression detection
- Migration tooling from Chef cookbooks
- Migration tooling from Ansible playbooks
- Migration tooling from Puppet manifests
- Compatibility shims for common legacy patterns
- Import/export tooling for existing inventories and variables
- Offline and air-gapped operation mode
- Signed offline bundle creation and verification
- Contributor-friendly local development environment
- Public plugin and module certification pipeline
- Stability channels for control plane and agents (`stable`, `candidate`, `edge`)
- Zero-downtime upgrade orchestration for agents and controllers
- N-1 protocol compatibility policy
- Release artifact signing and SBOM generation
